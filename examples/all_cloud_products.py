"""Example for Developer Meetup October 22 covering most cloud products, using research
from the Carbon Black Cloud Threat Analysis Unit (TAU).

References:
community.carbonblack.com/t5/Threat-Research-Docs/TAU-TIN-Egregor-Ransomware/ta-p/95786#
"""

import time
import logging
import json

# Audit and Remediation
from cbc_sdk.audit_remediation import Run, Result

# Live Response Helpers
from endpoint_standard.live_response_cli import CblrCli, connect_callback

# Endpoint Standard
from cbc_sdk.endpoint_standard import Policy

# Enterprise EDR
from cbc_sdk.enterprise_edr import Process, Watchlist, Report

# Platform Alerts and Devices
from cbc_sdk.platform import BaseAlert as PlatformAlert
from cbc_sdk.platform import Device as PlatformDevice

# CBC SDK Base
from cbc_sdk import CBCloudAPI

BOLD = "\033[1m"
UNBOLD = "\033[0m"

"""Setup"""

logging.basicConfig(filename="cloud_products_example_log.txt",
                    format='%(asctime)s,%(msecs)d %(levelname)-8s [%(filename)s:%(lineno)d] %(message)s',
                    datefmt='%H:%M:%S',
                    level=logging.INFO)

# API keys with relevant permissions
audit_remediation_api = CBCloudAPI(profile='audit_remediation')  # Live Query
live_response_api = CBCloudAPI(profile='live_response')  # Live Response
endpoint_standard_api = CBCloudAPI(profile='endpoint_standard')
enterprise_edr_api = CBCloudAPI(profile='enterprise_edr')
platform_api = CBCloudAPI(profile='platform')


def platform():
    """
    Platform Alerts and Devices operations, using research from TAU.

    1. Find Alerts matching Egregor ransomware, then
    2. Find Alerts matching a harmless query (demonstration purposes).
    """
    # Egregor ransomware tactics, techniques, and procedures (TTPs) identified by TAU
    egregor_ttps = ("DATA_TO_ENCRYPTION AND ACCESS_DATA_FILES AND PACKED_CALL AND"
                    "ENUMERATE_PROCESSES AND MODIFY_MEMORY_PROTECTION")
    print(f"\n{BOLD}**************************************\n"
          " 1a. Carbon Black Cloud Platform APIs \n"
          f"**************************************{UNBOLD}\n")

    print(f"Using {BOLD}Platform Alert Search{UNBOLD} to find Egregor Ransomware Alerts, based on Egregor Ransomware TTPs: \n{egregor_ttps}\n")

    # Find Alerts associated with the ransomware
    # Equivalent to using the UI Alerts tab with Advanced search turned on
    egregor_alerts = platform_api.select(PlatformAlert).where(egregor_ttps)

    # Expect this to be 0 in the testing environment
    num_egregor_alerts_string = f"Number of Alerts generated by Egregor Ransomware: {len(egregor_alerts)}"
    logging.info(num_egregor_alerts_string)
    print(num_egregor_alerts_string+"\n")

    # Find Alerts associated with innocuous query
    harmless_query = "yahoo"
    ioc_alerts = platform_api.select(PlatformAlert).where(harmless_query).set_create_time(range="-6d").set_group_results(True)

    unresolved_alerts = set()
    dismissed_alerts = set()
    unresolved_devices = set()

    print(f"Using {BOLD}Platform Alert Search{UNBOLD} to find more innocuous Alerts.\n")
    for alert in ioc_alerts:
        if alert.workflow_.state != "DISMISSED":
            """Platform Operations"""
            print(f"Found Alert ID {alert.id}. Quarantining the associated Device ID"
                  f" {alert.device_id}, and assigning it a strict Policy.\n")
            # Update the Alert remediation status and add comment
            alert.update(remediation="Investigating", comment=("Identified w/ CBCSDK. Proceeding to "
                                                               "quarantine and Live Response."))
            # Get the Device
            platform_device = platform_api.select(PlatformDevice, alert.device_id)
            # Quarantine the Device
            logging.info(f"Quarantining device {platform_device.name}")
            platform_device.quarantine(True)
            # Record current Policy ID
            previous_policy = platform_device.policy_id
            # Update Policy to something strict
            logging.info(f"Updating Policy of device {platform_device.name}")
            strict_policy = input(f"What Policy ID should be assigned to {platform_device.name}?: ")
            platform_device.update_policy(strict_policy)

            """Live Response Operations"""
            logging.info(f"Initiating Live Response session with {alert.device_id}")
            # Connect to Device for investigation
            try:
                endpoint_standard_live_response(alert.device_id)
            except KeyboardInterrupt:
                print("\nSkipping Live Response Session.\n")
                pass

            resolved = input("Was the issue resolved after Live Response session? (y/n): ")

            if resolved.lower().strip() == "y":
                print(f"\nDismissing Alert {alert.id}, removing the quarantine on Device ID {alert.device_id},"
                      " and reverting the Policy.\n")
                # Resolve the Alert
                alert.dismiss(remediation="Resolved", comment="Remedied with CBC SDK Live Response.")
                # Remove quarantine
                logging.info(f"Removing quarantine on device {platform_device.name}")
                platform_device.quarantine(False)
                # Revert Policy
                logging.info(f"Reverting Policy of device {platform_device.name} to Policy {previous_policy}")
                platform_device.update_policy(previous_policy)

            else:
                # Record info to log for further investigation later
                logging.info(f"Alert {alert.id} requires further investigation.")
                alert.update(remediation="Unresolved", comment=("Alert unresolved after Live Response. "
                                                                "Further investigation required. "
                                                                "Device remains quarantined."))
                unresolved_alerts.add(alert.id)
                unresolved_devices.add(alert.device_id)
        else:
            dismissed_alerts.add(alert.id)

    return (unresolved_alerts, dismissed_alerts, unresolved_devices)


def endpoint_standard_live_response(device_id, one_off=False):
    """
    Endpoint Standard Live Response operations.

    1. Connect to a loop command line, then
    2. (optionally) execute a one-off command.
    """
    print(f"\n{BOLD}************************************************************\n"
          " 1b. Carbon Black Cloud Endpoint Standard Live Response API \n"
          f"************************************************************{UNBOLD}\n")
    print(f"Using {BOLD}Endpoint Standard Live Response{UNBOLD} to investigate.\n")
    print(f"Establishing Live Response connection with Device ID {device_id}...\n")
    # Start a Live Response Session (using an example helper)
    command_line = CblrCli(live_response_api, connect_callback)
    # Connect to the Device
    command_line.do_connect(device_id)
    # Start a looping command line
    command_line.cmdloop()

    if one_off:
        # Execute a one-off command
        command_line.do_exec(r'cmd.exe /c "ping.exe 192.168.1.1"')


def endpoint_standard_policy(policy_id, rule_file):
    """
    Endpoint Standard Policy operations.

    1. Add new rules to a Policy.
    """
    print(f"\n{BOLD}****************************************************\n"
          " 2. Carbon Black Cloud Endpoint Standard Policy API \n"
          f"****************************************************{UNBOLD}\n")

    print(f"Updating Policy ID {policy_id} with rules from {rule_file}.\n")

    logging.info(f"Retrieving Policy {policy_id}")
    policy = endpoint_standard_api.select(Policy, policy_id)

    logging.info(f"Loading rule file {rule_file}")
    rules = json.load(open(rule_file, "r"))

    for rule in rules["rules"]:
        policy.add_rule(rule)

    policy_modification_string = f"Added {len(rules['rules'])} rules from {rule_file} to Policy {policy.name}"
    logging.info(policy_modification_string)
    print(policy_modification_string + "\n")


def create_eedr_report(iocs, title="", description="", severity=10):
    """Create an Enterprise EDR Report for a Watchlist."""
    report_creation_string = f"Creating Enterprise EDR Report '{title}'."
    logging.info(report_creation_string)
    print(report_creation_string+"\n")
    return Report(enterprise_edr_api, from_watchlist=True, initial_data=
                  {
                      "id": 1,
                      "timestamp": time.time(),
                      "title": title,
                      "description": description,
                      "severity": severity,
                      "iocs_v2": [iocs]
                  })


def enterprise_edr():
    """
    Enterprise EDR operations, using research from TAU.

    1. Find Processes with Indicators of Compromise (IOC's) matching Egregor ransomware, then
    2. Combine observed Process hashes with TAU research into Reports, finally
    3. Add the Reports to a new Watchlist.
    """
    print(f"\n{BOLD}****************************************************\n"
          " 3. Carbon Black Cloud Enterprise EDR Watchlist API \n"
          f"****************************************************{UNBOLD}\n")
    logging.info("Building Egregor ransomware Reports and Watchlist from IOCs")
    egregor_query = "filemod_count:[10000 TO *] filemod_name:recover-files.txt (modload_name:rundll32.exe OR modload_name:regsvr32.exe)"
    print(f"Using Enterprise EDR to create Threat Reports and a Watchlist, based on Egregor Ransomware IOCs: \n{egregor_query}\n")

    # Find Enterprise EDR Processes that match Egregor ransomware behavior
    egregor_ransomware_processes = enterprise_edr_api.select(Process).where(egregor_query)

    # Extract the Process hashes
    process_hashes = set()
    print("Finding Process hashes that matched Egregor IOC query.\n")
    for process in egregor_ransomware_processes:
        process_hashes.add(process.process_md5)
        process_hashes.add(process.process_sha256)

    # Create an Enterprise EDR Report with the found Process hashes
    ransomware_hashes_report = create_eedr_report(title="Egregor Ransomware MD5/SHA256 Hashes",
                                                  description="Process hashes suggesting Egregor ransomware behavior",
                                                  severity=10,
                                                  iocs={
                                                      "id": 1,
                                                      "match_type": "equality",
                                                      "field": "process_hash",
                                                      "values": list(process_hashes)
                                                  })
    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_hashes_report.save_watchlist()

    egregor_query = ("filemod_count:[10000 TO *] filemod_name:recover-files.txt "
                     "(modload_name:rundll32.exe OR modload_name:regsvr32.exe)")

    # Continuously monitor for any Processes that exhibit Egregor ransomware behavior
    ransomware_query_report = create_eedr_report(title="Egregor Ransomware Query",
                                                 description="IOCs suggesting ransomware behavior",
                                                 severity=10,
                                                 iocs={
                                                     "id": 1,
                                                     "match_type": "query",
                                                     "values": [egregor_query]
                                                 })

    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_query_report.save_watchlist()

    print("Creating an Engregor ransomware Watchlist.\n")

    # Create a new Watchlist to track ransomware Process hashes
    ransomware_watchlist = Watchlist(enterprise_edr_api, initial_data=
                                     {
                                         "name": "CBCSDK-Test",
                                         "description": "Egregor Ransomware Watchlist",
                                         "create_timestamp": time.time(),
                                         "last_update_timestamp": time.time(),
                                         "id": 1
                                     })
    # Save the new Watchlist
    ransomware_watchlist.save()

    # Add the Reports to the Watchlist
    logging.info(f"Adding Reports to Watchlist {ransomware_watchlist.id}")
    print("Adding Egregor ransomware SHA256/MD5 hashes Report and Query Report to Watchlist.\n")
    ransomware_watchlist.update(report_ids=[ransomware_hashes_report.id, ransomware_query_report.id])
    return ransomware_watchlist.id


def audit_remediation():
    """
    Audit and Remediation operations, using research from TAU.

    1. Execute SQL queries against endpoints in environment
    2. Retrieve run results
    """
    print(f"\n{BOLD}*************************************************\n"
          " 4. Carbon Black Cloud Audit and Remediation API \n"
          f"*************************************************{UNBOLD}\n")
    print(f"Using {BOLD}Audit and Remediation{UNBOLD} to create Live Query Runs, using queries found "
          "on the Query Exchange: \nhttps://community.carbonblack.com/t5/Query-Exchange/idb-p/query_exchange\n")
    # Find installed chrome extensions
    chrome_ext_sql = ("SELECT username, DIRECTORY, shell, TYPE, name, VERSION, "
                      "locale, update_url, author, persistent, PATH FROM users "
                      "JOIN chrome_extensions USING (UID);")
    chrome_ext_query = audit_remediation_api.select(Run).where(sql=chrome_ext_sql).name("Chrome Extensions")
    logging.info("Querying for Chrome Extensions")
    print("Querying for Chrome Extensions.\n")
    chrome_ext_run = chrome_ext_query.submit()
    chrome_ext_results_query = audit_remediation_api.select(Result).run_id(chrome_ext_run.id)

    # Find connected USB devices
    usb_devices_linux_mac_sql = "SELECT * FROM usb_devices;"
    usb_devices_query = audit_remediation_api.select(Run).where(sql=usb_devices_linux_mac_sql).name("USB Devices")
    logging.info("Querying for connected USB devices")
    print("Querying for connected USB devices.\n")
    usb_devices_run = usb_devices_query.submit()
    usb_devices_results = audit_remediation_api.select(Result).run_id(usb_devices_run.id)

    print(f"Queries submitted. Monitor here: {audit_remediation_api.url}/livequery/history\n")

    return (chrome_ext_run.id, usb_devices_run.id)


def cleanup(policy_id, watchlist_id, run_ids, dismissed_alerts):
    """Revert any changes to Alerts, Policies, Watchlists, or Live Query."""
    try:
        policy = endpoint_standard_api.select(Policy, policy_id)
        for rule in policy.rules:
            policy.delete_rule(rule)
    except Exception as e:
        logging.error(f"Failed to delete rules from Policy {policy_id}: {e}")

    if watchlist_id:
        try:
            watchlist = enterprise_edr_api.select(Watchlist, watchlist_id)
            watchlist.delete()
        except Exception as e:
            logging.error(f"Failed to delete Watchlist {watchlist_id}: {e}")

    if run_ids:

        for id in run_ids:
            try:
                run = audit_remediation_api.select(Run, id)
                run.delete()
            except Exception as e:
                logging.error(f"Failed to delete Live Query Run {id}: {e}")

    if dismissed_alerts:
        for id in dismissed_alerts:
            try:
                platform_api.select(PlatformAlert, id).update()
            except Exception as e:
                logging.error(f"Failed to reset Alert {id}: {e}")


def main():
    """Execute each product's example function."""
    # Variables to keep track of changes during example execution
    policy_id = None
    watchlist_id = None
    run_ids = None
    dismissed_alerts = None

    try:
        # Platform
        alerts, dismissed_alerts, devices = platform()
        if alerts:
            logging.warning(f"{len(alerts)} Alerts were not resolved: {alerts}")
        if devices:
            logging.warning(f"{len(devices)} Devices remain quarantined: {devices}")
        input(f"Press Return to continue to {BOLD}Endpoint Standard{UNBOLD} ")

        # Endpoint Standard
        print(f"\nUsing {BOLD}Endpoint Standard{UNBOLD} to add rules to a Policy.")
        policy_id = input("ID of Policy to modify: ")
        endpoint_standard_policy(policy_id, "examples/fixtures/egregor_rules.json")
        input(f"Press Return to continue to {BOLD}Enterprise EDR{UNBOLD} ")

        # Enterprise EDR
        watchlist_id = enterprise_edr()
        input(f"Press Return to continue to {BOLD}Audit and Remediation{UNBOLD} ")

        # Audit and Remediation
        run_ids = audit_remediation()
        input("Press Return to cleanup and end. ")

    except Exception as e:
        logging.error(f"Failed during main execution: {e}")
        pass

    logging.info("Cleaning up after demo")
    cleanup(policy_id, watchlist_id, run_ids, dismissed_alerts)


if __name__ == "__main__":
    main()
