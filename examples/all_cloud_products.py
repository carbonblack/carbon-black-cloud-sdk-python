"""Example for Developer Meetup October 22 covering most cloud products, using research
from the Carbon Black Cloud Threat Analysis Unit (TAU).

References:
community.carbonblack.com/t5/Threat-Research-Docs/TAU-TIN-Egregor-Ransomware/ta-p/95786#
community.carbonblack.com/t5/Threat-Research-Docs/SaltStack-salt-master-Remote-Code-Execution-Vulnerability-Post/ta-p/92299
"""

import time
import logging
import json

# Audit and Remediation
from cbc_sdk.audit_remediation import Run, Result

# Live Response Helpers
from endpoint_standard.live_response_cli import CblrCli, connect_callback

# Endpoint Standard
from cbc_sdk.endpoint_standard import Policy

# Enterprise EDR
from cbc_sdk.enterprise_edr import Process, Watchlist, Report

# Platform Alerts and Devices
from cbc_sdk.platform import BaseAlert as PlatformAlert
from cbc_sdk.platform import Device as PlatformDevice

# CBC SDK Base
from cbc_sdk import CBCloudAPI

"""Setup"""

logging.basicConfig(filename="cloud_products_example_log.txt",
                    format='%(asctime)s,%(msecs)d %(levelname)-8s [%(filename)s:%(lineno)d] %(message)s',
                    datefmt='%Y-%m-%d:%H:%M:%S',
                    level=logging.INFO)

# API keys with relevant permissions
audit_remediation_api = CBCloudAPI(profile='audit_remediation')  # Live Query
live_response_api = CBCloudAPI(profile='live_response')  # Live Response
endpoint_standard_api = CBCloudAPI(profile='endpoint_standard')
enterprise_edr_api = CBCloudAPI(profile='enterprise_edr')
platform_api = CBCloudAPI(profile='platform')


def platform():
    """
    Platform Alerts and Devices operations, using research from TAU.

    1. Find Alerts matching Egregor ransomware, then
    2. Find Alerts matching a harmless query (demonstration purposes).
    """
    # Egregor ransomware tactics, techniques, and procedures (TTPs) identified by TAU
    egregor_ttps = ("DATA_TO_ENCRYPTION AND ACCESS_DATA_FILES AND PACKED_CALL AND"
                    "ENUMERATE_PROCESSES AND MODIFY_MEMORY_PROTECTION")

    # Find Alerts associated with the ransomware
    # Equivalent to using the UI Alerts tab with Advanced search turned on
    egregor_alerts = platform_api.select(PlatformAlert).where(egregor_ttps)

    # Expect this to be 0 in the testing environment
    logging.info(f"Number of Alerts generated by Egregor Ransomware: {len(egregor_alerts)}")

    # Find Alerts associated with innocuous query
    harmless_query = "yahoo"
    ioc_alerts = platform_api.select(PlatformAlert).where(harmless_query).set_create_time(range="-6h").set_group_results(True)

    unresolved_alerts = set()
    dismissed_alerts = set()
    unresolved_devices = set()

    for alert in ioc_alerts:
        if alert.workflow_.state != "DISMISSED":
            """Platform Operations"""
            # Update the Alert remediation status and add comment
            alert.update(remediation="Investigating", comment=("Identified w/ CBCSDK. Proceeding to "
                                                               "quarantine and Live Response."))
            # Get the Device
            platform_device = platform_api.select(PlatformDevice, alert.device_id)
            # Quarantine the Device
            logging.info(f"Quarantining device {platform_device.name}")
            platform_device.quarantine(True)
            # Record current Policy ID
            previous_policy = platform_device.policy_id
            # Update Policy to something strict
            logging.info(f"Updating Policy of device {platform_device.name}")
            platform_device.update_policy(30241)

            """Live Response Operations"""
            logging.info(f"Initiating Live Response session with {alert.device_id}")
            # Connect to Device for investigation
            print(f"Establishing Live Response connection with Device ID {alert.id}")
            try:
                endpoint_standard_live_response(alert.device_id)
            except KeyboardInterrupt:
                print("\nSkipping Live Response Sesison")
                pass

            resolved = input("Issue resolved after Live Response session? (y/n): ")

            if resolved.lower().strip() == "y":
                # Resolve the Alert
                alert.dismiss(remediation="Resolved", comment="Remedied with CBC SDK Live Response.")
                # Remove quarantine
                logging.info(f"Removing quarantine on device {platform_device.name}")
                platform_device.quarantine(False)
                # Revert Policy
                logging.info(f"Reverting Policy of device {platform_device.name} to Policy {previous_policy}")
                platform_device.update_policy(previous_policy)

            else:
                logging.info(f"Alert {alert.id} requires further investigation.")
                alert.update(remediation="Unresolved", comment=("Alert unresolved after Live Response. "
                                                                "Further investigation required. "
                                                                "Device remains quarantined."))
                unresolved_alerts.add(alert.id)
                unresolved_devices.add(alert.device_id)
        else:
            dismissed_alerts.add(alert.id)

    return (unresolved_alerts, dismissed_alerts, unresolved_devices)


def endpoint_standard_live_response(device_id, one_off=False):
    """
    Endpoint Standard Live Response operations.

    1. Connect to a loop command line, then
    2. (optionally) execute a one-off command.
    """
    # Start a Live Response Session (using an example helper)
    command_line = CblrCli(live_response_api, connect_callback)
    # Connect to the Device
    command_line.do_connect(device_id)
    # Start a looping command line
    command_line.cmdloop()

    if one_off:
        # Execute a one-off command
        command_line.do_exec(r'cmd.exe /c "ping.exe 192.168.1.1"')


def endpoint_standard_policy(policy_id, rule_file):
    """
    Endpoint Standard Policy operations.

    1. Add new rules to a Policy.
    """
    print(f"Updating Policy {policy_id}")
    logging.info(f"Retrieving Policy {policy_id}")
    policy = endpoint_standard_api.select(Policy, policy_id)
    logging.info(f"Loading rule file {rule_file}")
    rules = json.load(open(rule_file, "r"))
    for rule in rules["rules"]:
        policy.add_rule(rule)
    logging.info(f"Added {len(rules['rules'])} rules from {rule_file} to policy {policy.name}")


def create_eedr_report(iocs, title="", description="", severity=10):
    """Create an Enterprise EDR Report for a Watchlist."""
    logging.info(f"Creating Enterprise EDR Report {title}")
    return Report(enterprise_edr_api, from_watchlist=True, initial_data=
                  {
                      "id": 1,
                      "timestamp": time.time(),
                      "title": title,
                      "description": description,
                      "severity": severity,
                      "iocs_v2": [iocs]
                  })


def enterprise_edr():
    """
    Enterprise EDR operations, using research from TAU.

    1. Find Indicators of Compromise (IOC's) matching Egregor ransomware, then
    2. Combine observed IOC's with TAU research into Reports, finally
    3. Add the Reports to a new Watchlist.
    """
    print("Creating Reports and Watchlist")
    logging.info("Building Egregor ransomware Reports and Watchlist from IOCs")
    # Find Enterprise EDR Processes that match Egregor ransomware behavior
    egregor_ransomware_processes = enterprise_edr_api.select(Process).where("filemod_count:[10000 TO *]")

    # Extract the Process hashes
    process_hashes = set()
    for process in egregor_ransomware_processes:
        process_hashes.add(process.process_md5)
        process_hashes.add(process.process_sha256)

    # Create an Enterprise EDR Report with the found Process hashes
    ransomware_hashes_report = create_eedr_report(title="Egregor Ransomware MD5/SHA256 Hashes",
                                                  description="IOCs suggesting ransomware behavior",
                                                  severity=10,
                                                  iocs={
                                                      "id": 1,
                                                      "match_type": "equality",
                                                      "field": "process_hash",
                                                      "values": list(process_hashes)
                                                  })
    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_hashes_report.save_watchlist()

    egregor_query = ("filemod_count:[10000 TO *] filemod_name:recover-files.txt "
                     "(modload_name:rundll32.exe OR modload_name:regsvr32.exe)")

    # Continuously monitor for any Processes that exhibit Egregor ransomware behavior
    ransomware_query_report = create_eedr_report(title="Egregor Ransomware Query",
                                                 description="IOCs suggesting ransomware behavior",
                                                 severity=10,
                                                 iocs={
                                                     "id": 1,
                                                     "match_type": "query",
                                                     "values": [egregor_query]
                                                 })

    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_query_report.save_watchlist()

    # Create a new Watchlist to track ransomware Process hashes
    ransomware_watchlist = Watchlist(enterprise_edr_api, initial_data=
                                     {
                                         "name": "CBCSDK-Test",
                                         "description": "Egregor Ransomware Watchlist",
                                         "create_timestamp": time.time(),
                                         "last_update_timestamp": time.time(),
                                         "id": 1
                                     })
    # Save the new Watchlist
    ransomware_watchlist.save()

    # Add the Reports to the Watchlist
    logging.info(f"Adding Reports to  Watchlist {ransomware_watchlist.id}")
    ransomware_watchlist.update(report_ids=[ransomware_hashes_report.id, ransomware_query_report.id])
    return ransomware_watchlist.id


def audit_remediation():
    """
    Audit and Remediation operations, using research from TAU.

    1. Execute SQL queries against endpoints in environment
    2. Retrieve run results
    """
    print("Creating Live Query Runs")
    # Find installed chrome extensions
    chrome_ext_sql = ("SELECT username, DIRECTORY, shell, TYPE, name, VERSION, "
                      "locale, update_url, author, persistent, PATH FROM users "
                      "JOIN chrome_extensions USING (UID);")
    chrome_ext_query = audit_remediation_api.select(Run).where(sql=chrome_ext_sql)
    logging.info("Querying for Chrome Extensions")
    chrome_ext_run = chrome_ext_query.submit()
    chrome_ext_results_query = audit_remediation_api.select(Result).run_id(chrome_ext_run.id)

    # Find connected USB devices
    usb_devices_linux_mac_sql = "SELECT * FROM usb_devices;"
    usb_devices_query = audit_remediation_api.select(Run).where(sql=usb_devices_linux_mac_sql)
    logging.info("Querying for connected USB devices")
    usb_devices_run = usb_devices_query.submit()
    usb_devices_results = audit_remediation_api.select(Result).run_id(usb_devices_run.id)

    print(f"Waiting for Live Query results. Monitor here: {audit_remediation_api.url}/livequery/history")
    # Record results of the Live Queries
    while chrome_ext_run.match_count == 0:
        logging.info("Waiting for results from Live Query")
        chrome_ext_run.refresh()
        time.sleep(5)
    logging.info("Chrome extensions query results:")
    for result in chrome_ext_results_query:
        logging.info(f"Device: {result.device_.name}, Chrome Extension: {result.fields_.name}")

    logging.info("USB devices query results:")
    for result in usb_devices_results:
        logging.info(usb_devices_results.fields_.name)

    return (chrome_ext_run.id, usb_devices_run.id)


def cleanup(policy_id, watchlist_id, run_ids, dismissed_alerts):
    """Revert any changes to Alerts, Policies, Watchlists, or Live Query."""
    policy = endpoint_standard_api.select(Policy, policy_id)
    for rule in policy.rules:
        policy.delete_rule(rule)

    if watchlist_id:
        watchlist = enterprise_edr_api.select(Watchlist, watchlist_id)
        watchlist.delete()

    if run_ids:
        for id in run_ids:
            run = audit_remediation_api.select(Run, id)
            run.delete()

    if dismissed_alerts:
        for id in dismissed_alerts:
            platform_api.select(PlatformAlert, id).update()


def main():
    """Execute each product's example function."""
    # Variables to keep track of changes during example execution
    policy_id = None
    watchlist_id = None
    run_ids = None
    dismissed_alerts = None

    try:
        # Platform
        alerts, dismissed_alerts, devices = platform()
        if alerts:
            logging.warning(f"{len(alerts)} Alerts were not resolved: {alerts}")
        if devices:
            logging.warning(f"{len(devices)} Devices remain quarantined: {devices}")

        # Endpoint Standard
        policy_id = input("ID of Policy to modify: ")
        endpoint_standard_policy(policy_id, "examples/fixtures/egregor_rules.json")

        # Enterprise EDR
        watchlist_id = enterprise_edr()

        # AUdit and Remediation
        run_ids = audit_remediation()

    except Exception as e:
        logging.error(e)
        pass

    logging.info("Cleaning up after demo")
    cleanup(policy_id, watchlist_id, run_ids, dismissed_alerts)


if __name__ == "__main__":
    main()
