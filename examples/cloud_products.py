"""Example for Developer Meetup October 22 covering most cloud products, using research
from the Carbon Black Cloud Threat Analysis Unit (TAU).

References:
community.carbonblack.com/t5/Threat-Research-Docs/TAU-TIN-Egregor-Ransomware/ta-p/95786#
community.carbonblack.com/t5/Threat-Research-Docs/SaltStack-salt-master-Remote-Code-Execution-Vulnerability-Post/ta-p/92299
"""

import time
import logging
import json

# Audit and Remediation
from cbc_sdk.audit_remediation import Run, RunHistory, Result, DeviceSummary

# Live Response
from endpoint_standard.live_response_cli import CblrCli, connect_callback

# Endpoint Standard
from cbc_sdk.endpoint_standard import Policy
from cbc_sdk.endpoint_standard import Event as EndpointStandardEvent
from cbc_sdk.endpoint_standard import Device as EndpointStandardDevice

# Enterprise EDR
from cbc_sdk.enterprise_edr import Feed, Event, Process, Tree, Watchlist, Report, IOC, IOC_V2

# Platform Alerts and Devices
from cbc_sdk.platform import BaseAlert as PlatformAlert
from cbc_sdk.platform import Device as PlatformDevice

# CBC SDK Base
from cbc_sdk import CBCloudAPI

"""Setup"""

logging.basicConfig(filename="cloud_products_example_log.txt")

# API keys with relevant permissions
audit_remediation_api = CBCloudAPI(profile='audit_remediation')  # Live Query
live_response_api = CBCloudAPI(profile='live_response')  # Live Response
endpoint_standard_api = CBCloudAPI(profile='endpoint_standard')
enterprise_edr_api = CBCloudAPI(profile='enterprise_edr')
platform_api = CBCloudAPI(profile='platform')


def platform():
    """
    Platform Alerts and Devices operations, using research from TAU.

    1. Find Alerts matching Egregor ransomware, then
    2. Find Alerts matching a harmless query (demonstration purposes).
    """

    # Egregor ransomware tactics, techniques, and procedures (TTPs) identified by TAU
    egregor_ttps = ("DATA_TO_ENCRYPTION AND ACCESS_DATA_FILES AND PACKED_CALL AND"
                    "ENUMERATE_PROCESSES AND MODIFY_MEMORY_PROTECTION")

    # Find Alerts associated with the ransomware
    # Equivalent to using the UI Alerts tab with Advanced search turned on
    egregor_alerts = platform_api.select(PlatformAlert).where(egregor_ttps)

    # Expect this to be 0 in the testing environment
    logging.debug(f"Number of Alerts generated by Egregor Ransomware: {len(egregor_alerts)}")

    # Find Alerts associated with innocuous query
    harmless_query = "yahoo"
    ioc_alerts = platform_api.select(PlatformAlert).where(harmless_query).set_create_time(range="-6h").set_group_results(True)

    unresolved_alerts = set()
    unresolved_devices = set()

    for alert in ioc_alerts:
        if alert.workflow_.state != "DISMISSED":
            """Platform Operations"""
            # Update the Alert remediation status and add comment
            alert.update(remediation="Investigating", comment=("Identified w/ CBCSDK. Proceeding to "
                                                               "quarantine and Live Response."))
            # Get the Device
            platform_device = platform_api.select(PlatformDevice, alert.device_id)
            # Quarantine the Device
            logging.debug(f"Quarantining device {platform_device.name}")
            platform_device.quarantine(True)
            # Record current Policy ID
            previous_policy = platform_device.policy_id
            # Update Policy to something strict
            logging.debug(f"Updating Policy of device {platform_device.name}")
            platform_device.update_policy(30241)

            """Live Response Operations"""
            logging.debug(f"Initiating Live Response session with {alert.device_id}")
            # Connect to Device for investigation
            endpoint_standard_live_response(alert.device_id)

            resolved = input("Issue resolved after Live Response session? (y/n): ")

            if resolved.lower().strip() == "y":
                # Resolve the Alert
                alert.dismiss(remediation="Resolved", comment="Remedied with CBC SDK Live Response.")
                # Remove quarantine
                logging.debug(f"Removing quarantine on device {platform_device.name}")
                platform_device.quarantine(False)
                # Revert Policy
                logging.debug(f"Reverting Policy of device {platform_device.name} to Policy {previous_policy}")
                platform_device.update_policy(previous_policy)

            else:
                logging.info(f"Alert {alert.id} requires further investigation.")
                alert.update(remediation="Unresolved", comment=("Alert unresolved after Live Response. "
                                                                "Further investigation required. "
                                                                "Device remains quarantined."))
                unresolved_alerts.add(alert.id)
                unresolved_devices.add(alert.device_id)

    return (unresolved_alerts, unresolved_devices)


def endpoint_standard_live_response(device_id, one_off=False):
    """
    Endpoint Standard Live Response operations.

    1. Connect to a loop command line, then
    2. (optionally) execute a one-off command.
    """
    # Start a Live Response Session (using an example helper)
    command_line = CblrCli(live_response_api, connect_callback)
    # Connect to the Device
    command_line.do_connect(device_id)
    # Start a looping command line
    command_line.cmdloop()

    if one_off:
        # Execute a one-off command
        command_line.do_exec(r'cmd.exe /c "ping.exe 192.168.1.1"')


def endpoint_standard_policy(policy_id, rule_file):
    """
    Endpoint Standard Policy operations.

    1. Add new rules to a Policy.
    """
    logging.debug(f"Retrieving Policy {policy_id}")
    policy = endpoint_standard_api.select(Policy, policy_id)
    logging.debug(f"Loading rule file {rule_file}")
    rules = json.load(open(rule_file), "r")
    for rule in rules:
        policy.add_rule(rule)
        logging.debug(f"Added rule from {rule_file} to policy {policy.name}")


def create_eedr_report(iocs, title="", description="", severity=10):
    """Create an Enterprise EDR Report for a Watchlist."""
    logging.debug(f"Creating Enterprise EDR Report {title}")
    return Report(enterprise_edr_api, from_watchlist=True, initial_data=
                  {
                      "id": 1,
                      "timestamp": time.time(),
                      "title": title,
                      "description": description,
                      "severity": severity,
                      "iocs_v2": [iocs]
                  })


def enterprise_edr():
    """
    Enterprise EDR operations, using research from TAU.

    1. Find Indicators of Compromise (IOC's) matching Egregor ransomware, then
    2. Combine observed IOC's with TAU research into Reports, finally
    3. Add the Reports to a new Watchlist.
    """
    logging.debug("Building Egregor ransomware Reports and Watchlist from IOCs")
    # Find Enterprise EDR Processes that match Egregor ransomware behavior
    egregor_ransomware_processes = enterprise_edr_api.select(Process).where("filemod_count:[10000 TO *]")

    # Extract the Process hashes
    process_hashes = set()
    for process in egregor_ransomware_processes:
        process_hashes.add(process.process_md5)
        process_hashes.add(process.process_sha256)

    # Create an Enterprise EDR Report with the found Process hashes
    ransomware_hashes_report = create_eedr_report(title="Egregor Ransomware MD5/SHA256 Hashes",
                                                  description="IOCs suggesting ransomware behavior",
                                                  severity=10,
                                                  iocs={
                                                      "match_type": "equality",
                                                      "field": "process_hash",
                                                      "values": list(process_hashes)
                                                  })
    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_hashes_report.save_watchlist()

    egregor_query = "filemod_count:[10000 TO *] filemod_name:recover-files.txt (modload_name:rundll32.exe OR modload_name:regsvr32.exe)"

    # Continuously monitor for any Processes that exhibit Egregor ransomware behavior
    ransomware_query_report = create_eedr_report(title="Egregor Ransomware Query",
                                                 description="IOCs suggesting ransomware behavior",
                                                 severity=10,
                                                 iocs={
                                                     "match_type": "query",
                                                     "values": [egregor_query]
                                                 })

    # Save the Report as a Watchlist Report (vs. a Feed Report)
    ransomware_query_report.save_watchlist()

    # Create a new Watchlist to track ransomware Process hashes
    ransomware_watchlist = Watchlist(enterprise_edr_api, initial_data=
                                     {
                                         "name": "CBCSDK-Test",
                                         "description": "Egregor Ransomware Watchlist",
                                         "create_timestamp": time.time(),
                                         "last_update_timestamp": time.time(),
                                         "id": 1
                                     })
    # Save the new Watchlist
    ransomware_watchlist.save()

    # Add the Reports to the Watchlist
    logging.debug(f"Adding Reports to  Watchlist {ransomware_watchlist.id}")
    ransomware_watchlist.update(report_ids=[ransomware_hashes_report.id, ransomware_query_report.id])


def audit_remediation():
    """
    Audit and Remediation operations, using research from TAU.

    1. Execute SQL queries against endpoints in environment
    """
    # Find installed chrome extensions
    chrome_ext_sql = ("SELECT username, DIRECTORY, shell, TYPE, name, VERSION, "
                      "locale, update_url, author, persistent, PATH FROM users "
                      "JOIN chrome_extensions USING (UID);")
    chrome_ext_query = audit_remediation_api.select(Run).where(sql=chrome_ext_sql)
    logging.debug("Querying for Chrome Extensions")
    chrome_ext_run = chrome_ext_query.submit()
    chrome_ext_results = audit_remediation_api.select(Result).run_id(chrome_ext_run.id)
    logging.debug(f"Chrome extensions query results: {chrome_ext_results}")

    # Find vulnerable versions of salt-master
    salt_master_remote_code_vuln_sql = ("WITH packages AS (SELECT name, VERSION FROM rpm_packages"
                                        "WHERE NAME = 'salt-master' UNION SELECT name, VERSION FROM "
                                        "deb_packages WHERE NAME = 'salt-master') SELECT CASE WHEN NOT "
                                        "((major = 3000 AND minor >= 2) OR (major = 2019 AND minor >= 2 AND patch >= 4)) "
                                        "THEN 'Vulnerable - PATCH Immediately: ' || name || ' ' || VERSION "
                                        "ELSE NULL END 'SALT CVE-2020-11651/11652' FROM (SELECT name, VERSION, "
                                        "cast(split(VERSION, '.', 0) AS int) AS major, cast(split(VERSION, '.', 1) "
                                        "AS int) AS minor, cast(split(VERSION, '.', 2) AS int) AS patch FROM packages "
                                        "WHERE name = 'salt-master');")
    salt_master_query = audit_remediation_api.select(Run).where(sql=salt_master_remote_code_vuln_sql)
    logging.debug("Querying for salt-master vulnerabilities")
    salt_master_run = salt_master_query.submit()
    salt_master_results = audit_remediation_api.select(Result).run_id(salt_master_run.id)
    logging.debug(f"Salt-master vulnerability query results: {salt_master_results}")

    # Find connected USB devices
    usb_devices_linux_mac_sql = "SELECT * FROM usb_devices;"
    usb_devices_query = audit_remediation_api.select(Run).where(sql=usb_devices_linux_mac_sql)
    logging.debug("Querying for connected USB devices")
    usb_devices_run = usb_devices_query.submit()
    usb_devices_results = audit_remediation_api.select(Result).run_id(usb_devices.id)
    logging.debug(f"USB devices query results: {usb_devices_results}")


def main():
    alerts, devices = platform()
    if alerts:
        logging.warning(f"{len(alerts)} Alerts were not resolved: {alerts}")
    if devices:
        logging.warning(f"{len(devices)} Devices remain quarantined: {devices}")
    endpoint_standard_policy(30241, "egregor_rules.json")
    enterprise_edr()
    audit_remediation()


if __name__ == "__main__":
    main()
